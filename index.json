[{"content":"This post was originally published on my Medium profile : A concise guide to gRPC for beginners\n A series of simple, beginner friendly tutorials that explain the what, why and how of gRPC.\n Getting started - Understanding RPC What is RPC?  RPC aka Remote Procedure Calls - are just like functions. These functions are executed on some remote system and hence the name. It follows a request - response model. A request is initiated from the client - this request is a function call with certain parameters and then, the server returns a response. Real world application - to construct distributed, scalable, client - server based applications.  gRPC  gRPC is a technology to implement RPC APIs.  Can write servers and clients using different programming languages - a client written using Python can interact with a server written in Golang. By default gRPC uses protocol buffers as the interface definition language (IDL) to define the RPC services and the structure of the payload messages.  Understanding protocol buffers and .proto files What is protobuf?  Protocol buffers are a way to serialize structured data in an efficient manner. It uses the method of binary serialization, which is faster than text based serialization methods like JSON. The protobuf specification can be implemented in various programming languages.  What is a .proto file A .proto file will contain the necessary definitions to see the protocol buffers in action. A file with .proto extension will contain the definitions of messages and services. The services are analogous to procedures/functions and the messages are analogous to the data types of the parameters that can be passed to these functions.\nsyntax = \u0026#34;proto3\u0026#34;; message UrlRequest{ string req = 1; } message UrlResponse{ int res = 1; } service Url{ rpc CallUrl(UrlRequest) returns (UrlResponse){} } In the above example, the first line of the file specifies that you\u0026rsquo;re using proto3 syntax, CallUrl is a service, UrlRequest and UrlResponse are the message definitions. We can see that the RPC service - CallUrl acts as a function with input parameter as UrlRequest and output as UrlResponse. The message definitions can have fields within them. Each field has a name and a type. Here we have req field which has the data type string in UrlRequest and res is a field whose data type is int in UrlResponse.\nImportant step - Compiling a .proto file\n This generates helper code to implement the server and client code in the programming language of your choice. The generated code also handles the parsing of structured data as the data is serialised into a binary format which can be transferred more efficiently as compared to text based serialisation methods like JSON, XML.  Further Reading - Language Guide (proto3)\nLet\u0026rsquo;s Code Basic Workflow  Define the protocol - Write a .proto file  Define messages Define RPC service procedures with their respective parameters and return types. There can be 4 types of RPC procedures:  simple RPC server-side streaming RPC client-side streaming RPC bidirectional streaming RPC   Compile .proto file - generates protobuf related code for binary serialization of data; also generates client and server stubs   Write Server and Client code using language of your choice with the help of the generated stubs  gPRC currently supports the following languages -  C# C++ Dart Go Java Kotlin Node Objective-C PHP Python Ruby     Compile and run the final application  Further reading:\ngRPC Documentation\ngRPC vs REST: Understanding gRPC, OpenAPI and REST and when to use them in API design\n","permalink":"https://penthaapatel.github.io/posts/a-concise-guide-to-grpc-services-for-beginners/","summary":"This post was originally published on my Medium profile : A concise guide to gRPC for beginners\n A series of simple, beginner friendly tutorials that explain the what, why and how of gRPC.\n Getting started - Understanding RPC What is RPC?  RPC aka Remote Procedure Calls - are just like functions. These functions are executed on some remote system and hence the name. It follows a request - response model.","title":"A concise guide to gRPC services for beginners"},{"content":"This post was originally published on my Medium profile : How to implement a simple gRPC service using Golang\nIf you want a general introduction to RPC you might want to check out my previous article in this series - A concise guide to gRPC for beginners\nThe implemented code can be found on my GitHub Repository : Link to GitHub repository\nBefore you begin  Install Golang Install proto compilers  Workflow  Define protocol - Write .proto file Compile it - generate necessary protobuf related files and client and server stubs Write Client code Write Server code Run the server and client code, check if it works  A simple RPC service that can create blog posts Overview\n Client sends a request to the server to create a blog post with a given title and contents. The server saves the newly created blog posts in an in-memory storage. Since this particular article focuses on implementing RPC services, we use an in-memory storage to save out blog posts. This in-memory storage can be replaced with any database at the backend later. The database can be integrated later by utilising the power of interfaces in Golang.  Directory structure grpcblog ├── Makefile ├── blog │ ├── blog.pb.go │ ├── blog.proto │ └── blog_grpc.pb.go ├── client │ └── client.go ├── server │ └── server.go ├── storage └── storage.go .proto file  message Blog defines the structure of the blog post and contains 2 fields - title and body.  message Blog{ string title = 1; string body =2; }  message BlogRequest defines the structure of the client request - has 1 field - Blog.  message BlogRequest { Blog blog = 1; }  message BlogResponse defines the structure of the server response - contains 2 fields -  id : a universally unique identifier (UUID) generated on successful creation of a new post. created : a boolean value set to true if CreatePost is successful; false otherwise.    message BlogResponse{ string id = 1; bool created = 2; }  The proto file contains a simple RPC service CreatePost - client sends a single request to the server and the server responds back with a single response. The RPC service CreatePost sends a BlogRequest from the client and the server responds with a BlogResponse.  service BlogService{ rpc CreatePost(BlogRequest) returns (BlogResponse) {} } Compiling the .proto files Use the following command to compile the .protofiles:\nprotoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative blog/blog.proto This will generate two files:\nblog/blog_grpc.pb.go blog_grpc.pb.go contains server and client stubs. The interfaces BlogServiceClient and BlogServiceServer are not implemented. These interfaces will be later implemented in our server and client code. We will have to write own own implementation of server and client.\nblog/blog.pb.go blog.pb.go contains protocol buffer code - responsible for binary serialization of data when it is transported between server and client.\nDefine in-memory storage  storage.go contains custom functions to implement the temporary in-memory storage. Contains an interface BlogStorage interface with a Save() and a View() function.  type BlogStorage interface { Save(blog *blog.Blog, id string) error View() } type InMemoryBlogStorage struct { mutex sync.RWMutex blogs map[string]*blog.Blog }  Blogs are saved in a map where key is the UUID and the value associated with it is the blog post. To save the posts to a database, we can add another function like SaveToDB() that implements the BlogStorage interface.  Client code  Reads in the blog title from the console. Reads in the blog contents from the console. Contains the implementation of the function CreatePost that was unimplemented in BlogServiceClient interface in blog/blog_grpc.pb.go.  Server code  Creates and saves new blog posts to the in-memory storage by taking input data from the client. Contains the implementation of the function CreatePost that was unimplemented in BlogServiceServer interface in blog/blog_grpc.pb.go. Generates a universally unique identifier (UUID) when a new post is created and saved to the in-memory storage Displays UUID of each new post upon successful creation of a new post  Final result Run the server and client code in two separate terminals. Run server\ngo run server/server.go Run client - Enter title and contents for the new blog post.\nAnd hurray! We have successfully created a new post using gRPC service.\nFurther reading - Some useful resources:\n gRPC Go Quick Start Protocol Buffer Basics: Go Basic introduction to gRPC in Go proto3 language Guide  ","permalink":"https://penthaapatel.github.io/posts/how-to-implement-a-simple-rpc-service-using-golang/","summary":"This post was originally published on my Medium profile : How to implement a simple gRPC service using Golang\nIf you want a general introduction to RPC you might want to check out my previous article in this series - A concise guide to gRPC for beginners\nThe implemented code can be found on my GitHub Repository : Link to GitHub repository\nBefore you begin  Install Golang Install proto compilers  Workflow  Define protocol - Write .","title":"How to implement a simple RPC service using Golang"},{"content":"This post was originally published on my Medium profile : Difference between functions and methods in Golang\nThe words function and method are used almost interchangeably, but there are subtle differences in their implementation and usage when used in Golang. Let\u0026rsquo;s see what the difference is and how its used.\nFunction Functions accept a set of input parameters, perform some operations on the input and produce an output with a specific return type. Functions are independent that is they are not attached to any user defined type.\nSyntax:\nfunc FunctionName(Parameters...) ReturnTypes... There cannot exist two different functions with the same name in the same package.\ntype Rectangle struct { Width float64 Height float64 } type Circle struct { Radius float64 } func Area(r Rectangle) float64 { return 2 * r.Height * r.Width } func Area(c Circle) float64 { return math.Pi * c.Radius * c.Radius } Run above code in The Go Playground\nThe above code throws an error : Area redeclared in this block\nMethod A method is effectively a function attached to a user defined type like a struct. This user defined type is called a receiver.\nSyntax:\nfunc (t ReceiverType) FunctionName(Parameters...) ReturnTypes... There can exist different methods with the same name with a different receiver.\ntype Rectangle struct { Width float64 Height float64 } func (r Rectangle) Area() float64 { return r.Width * r.Height } type Circle struct { Radius float64 } func (c Circle) Area() float64 { return math.Pi * c.Radius * c.Radius } type Triangle struct { Base float64 Height float64 } func (t Triangle) Area() float64 { return 0.5 * t.Base * t.Height } Run above code in The Go Playground\n","permalink":"https://penthaapatel.github.io/posts/difference-between-functions-and-methods-in-golang/","summary":"This post was originally published on my Medium profile : Difference between functions and methods in Golang\nThe words function and method are used almost interchangeably, but there are subtle differences in their implementation and usage when used in Golang. Let\u0026rsquo;s see what the difference is and how its used.\nFunction Functions accept a set of input parameters, perform some operations on the input and produce an output with a specific return type.","title":"Difference between functions and methods in Golang"},{"content":"This post was originally published on my Dev.to profile : Contributing to Open Source Go projects on GitHub — A recipe to clone forked Go repos.\nPhew! It took me a while to figure out the entire process so I decided to write this post and I hope it\u0026rsquo;ll further help everyone else get started. I managed to gather all the ingredients and curate the recipe to start working on an open source Golang project…so follow along.\nSay you want to experiment with org\u0026rsquo;s new tool which is written in Go. So, you go to get (pun intended) the repo which you have forked on your GitHub account.\nQuestion : Why your regular go get on the forked repo won\u0026rsquo;t work? Simple Answer : All your imports will be messed up. You\u0026rsquo;ll have to change all the import statements that say something like github.com/org/tool to github.com/yourGitHubID/tool to make things work and your code will run into conflicts.\ngo get the original org\u0026rsquo;s repo. go get clones the repo into your GOPATH . -u flag updates the named packages and their dependencies.\n$ go get -u github.com/org/tool  Go to the directory where you just cloned the org\u0026rsquo;s tool repo\n$ cd $GOPATH/src/github.com/org/tool  Let\u0026rsquo;s check what remote repos we have at this point. List out the remote repositories. -v for a verbose output.\n$ git remote -v origin https://github.com/org/tool (fetch) origin https://github.com/org/tool (push)  Add a add a new remote Git repository explicitly pointing at your fork. Here the shortname I used for the new remote is fork, you can name it whatever you like.\n$ git remote add fork https://github.com/yourGitHubID/tool.git  List out the remote repositories again to check and there you see it, a new remote has been added.\n$ git remote -v fork https://github.com/yourGitHubID/tool.git (fetch) fork https://github.com/yourGitHubID/tool.git (push) origin https://github.com/org/tool (fetch) origin https://github.com/org/tool (push)  Now that you have a remote that points to the forked repo on your GitHub account, you can start working. To start working on a new branch:\n$ git checkout -b experimentbranch  Make sure you have your branch updated with org\u0026rsquo;s branch. Then you can start making changes to the files on the experimentbranch git add your modified files and git commit your work after testing the new features you\u0026rsquo;ve added.\nPush changes to your fork.\n$ git push -u fork experimentbranch:experimentbranch  Then you can compare the changes you have made and submit a Pull Request to propose changes to be merged with the org\u0026rsquo;s repository.\nIf you notice any corrections that need to be made in the post feel free to comment below! :)\n","permalink":"https://penthaapatel.github.io/posts/contributing-to-open-source-go-projects-on-github-a-recipe-to-clone-forked-go-repositories/","summary":"This post was originally published on my Dev.to profile : Contributing to Open Source Go projects on GitHub — A recipe to clone forked Go repos.\nPhew! It took me a while to figure out the entire process so I decided to write this post and I hope it\u0026rsquo;ll further help everyone else get started. I managed to gather all the ingredients and curate the recipe to start working on an open source Golang project…so follow along.","title":"Contributing to Open Source Go projects on GitHub - A recipe to clone forked Go repositories"},{"content":"This post was originally published on my Medium profile : Golang-How to parse JSON data into a nested struct\nSay you are fetching data from a RESTful API using GET requests and want to store the JSON responses. One of the ways to achieve this is by parsing the JSON data into a Go struct. The following example will fetch data related to standings of a football league, UEFA Champions League in this case.\nRESTful API used : https://www.football-data.org/\nYou’ll need a free API key to access the data.\nConstruct a blueprint of the struct: Here’s a useful tool that converts JSON to a Go struct type. I have removed a few fields to make the struct simpler. Each field is associated with a JSON tag.\n Construct separate struct types for JSON objects that are arrays. In the following example a separate type is constructed for Standing and Table and the fields Standings is a slice of Standing i.e. []Standing and Tables is a slice of Table i.e. []Table .\n type Competitions struct { Competition struct { Name string `json:\u0026#34;name\u0026#34;` } `json:\u0026#34;competition\u0026#34;` Season struct { CurrentMatchday int `json:\u0026#34;currentMatchday\u0026#34;` Winner interface{} `json:\u0026#34;winner\u0026#34;` } `json:\u0026#34;season\u0026#34;` Standings []Standing `json:\u0026#34;standings\u0026#34;` } type Standing struct { Stage string `json:\u0026#34;stage\u0026#34;` Type string `json:\u0026#34;type\u0026#34;` Group string `json:\u0026#34;group\u0026#34;` Tables []Table `json:\u0026#34;table\u0026#34;` } type Table struct { Position int `json:\u0026#34;position\u0026#34;` Team struct { Name string `json:\u0026#34;name\u0026#34;` } `json:\u0026#34;team\u0026#34;` PlayedGames int `json:\u0026#34;playedGames\u0026#34;` Won int `json:\u0026#34;won\u0026#34;` Draw int `json:\u0026#34;draw\u0026#34;` Lost int `json:\u0026#34;lost\u0026#34;` Points int `json:\u0026#34;points\u0026#34;` GoalsFor int `json:\u0026#34;goalsFor\u0026#34;` GoalsAgainst int `json:\u0026#34;goalsAgainst\u0026#34;` GoalDifference int `json:\u0026#34;goalDifference\u0026#34;` } Get JSON data from the API: GetData function returns a slice of byte. It does the following tasks:\n Makes an HTTP GET request; Sets the “X-Auth-Token” in request header; Sets up an HTTP Client that makes an HTTP request and returns an HTTP response, following the auth-token as configured. Reads HTTP response body that contains JSON data and converts it to a []byte.  The []byte returned can be used to parse JSON encoded data into any struct type using [json.Unmarshal](https://golang.org/pkg/encoding/json/#Unmarshal).\nfunc GetData(url, apiKey string) []byte { request, err := http.NewRequest(\u0026#34;GET\u0026#34;, url, nil) if err != nil { panic(err) } request.Header.Set(\u0026#34;X-Auth-Token\u0026#34;, apiKey) var client = http.Client{} response, err := client.Do(request) if err != nil { panic(err) } defer response.Body.Close() jsonByte, err := ioutil.ReadAll(response.Body) if err != nil { panic(err) } return jsonByte } Parse JSON into the struct Parse JSON into **Competitions** struct:GetStandings function takes the league id as an argument to build the final url and returns a Competitions struct that has the parsed JSON data in it.\n [json.Unamrshal](https://golang.org/pkg/encoding/json/#Unmarshal) parses the JSON-encoded data that is in []byte and stores the result in the struct whose address is given by \u0026amp;s .\n Note: To make successful GET requests, set the variable apikey.\nfunc GetStandings(id string) (s Competitions) { /* id can be BSA Brazilian Division One League PL Premiere League League ELC Championship League CL Champions League Cup EC European Championships Cup FL1 France League 1 League BL1 Bundesliga League SA Italy Serie A League DED Eredivise League PPL Portuguese Primera Division League PD Primera Division League WC World Cup */ url := \u0026#34;https://api.football-data.org/v2/competitions/\u0026#34; + id + \u0026#34;/standings\u0026#34; apikey := \u0026#34;SetYourAPIkeyHere\u0026#34; d := GetData(url, apikey) err := json.Unmarshal(d, \u0026amp;s) if err != nil { panic(err) } //Uncomment this section to pretty print json on terminal \t/* data, err := json.MarshalIndent(s, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { panic(err) } fmt.Println(string(data)) */ return } Voila!\nPrint the struct on terminal using the format verb %+v variant that will include the struct’s field names or use package spew that prints some additional information about the struct.\nfunc main() { //id = CL for Champions League Standings \tfmt.Printf(\u0026#34;%+v\u0026#34;, GetStandings(\u0026#34;CL\u0026#34;)) //Or using package spew \tspew.Dump(GetStandings(\u0026#34;CL\u0026#34;)) } ","permalink":"https://penthaapatel.github.io/posts/golang-how-to-parse-json-data-into-a-nested-struct/","summary":"This post was originally published on my Medium profile : Golang-How to parse JSON data into a nested struct\nSay you are fetching data from a RESTful API using GET requests and want to store the JSON responses. One of the ways to achieve this is by parsing the JSON data into a Go struct. The following example will fetch data related to standings of a football league, UEFA Champions League in this case.","title":"Golang-How to parse JSON data into a nested struct"},{"content":"Hi there! 👋\nI\u0026rsquo;m an aspiring software developer from India 🇮🇳 I recently graduated from IIIT Bh with a Bachelor\u0026rsquo;s in Computer Science and Engineering and I am open to entry-level programming roles right now.\nI code mostly using Go. I have developed individual projects that implement REST APIs, gRPC protocols. To view these projects and my other Open Source contributions to various repositories, feel free to visit my GitHub profile.\nFollow along my programming journey here on my blog where I document my learnings. The posts I publish here are accompanied by code snippets and complete source code for easier understanding.\nApart from programming, I love to paint,draw 🎨 and play chess ♟.\nIf you would like to connect, feel free to send in a message on LinkedIn or write to me at penthaapatel[at]gmail[dot]com.\nLink to socials:\n   ","permalink":"https://penthaapatel.github.io/about/","summary":"Hi there! 👋\nI\u0026rsquo;m an aspiring software developer from India 🇮🇳 I recently graduated from IIIT Bh with a Bachelor\u0026rsquo;s in Computer Science and Engineering and I am open to entry-level programming roles right now.\nI code mostly using Go. I have developed individual projects that implement REST APIs, gRPC protocols. To view these projects and my other Open Source contributions to various repositories, feel free to visit my GitHub profile.","title":"About Me"},{"content":"grpcblog Implementation of a gRPC service using Go. It uses protocol buffers to serialize data, which is a more efficient means of transporting data over the network as compared to text based serializations.\nProject link : github.com/penthaapatel/grpcblog\ngoodfoodsAPI A HTTP RESTful API written in Go accessing MongoDB Database using MongoDB Go Driver. The API supports CRUD - Create, Read, Update, Delete operations using the API endpoints.\nProject link : github.com/penthaapatel/goodfoodsAPI\nblockchain network A blockchain implementation written in Go. It uses SHA256 algorithm to generate the hash of a newly generated block.\nProject link : github.com/penthaapatel/blockchainnetwork\n","permalink":"https://penthaapatel.github.io/projects/","summary":"grpcblog Implementation of a gRPC service using Go. It uses protocol buffers to serialize data, which is a more efficient means of transporting data over the network as compared to text based serializations.\nProject link : github.com/penthaapatel/grpcblog\ngoodfoodsAPI A HTTP RESTful API written in Go accessing MongoDB Database using MongoDB Go Driver. The API supports CRUD - Create, Read, Update, Delete operations using the API endpoints.\nProject link : github.com/penthaapatel/goodfoodsAPI","title":"Projects"}]